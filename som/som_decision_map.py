import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

from train_som import *

import sys
import os
sys.path.insert(1, os.path.join(sys.path[0], '..'))

import pickle
import time
import torch
from torch.autograd import Variable
import numpy as np
import matplotlib.lines as mlines
from utils.utils import load_parameters


if __name__ == "__main__":

    params_filepath = sys.argv[1]
    parameters = load_parameters(params_filepath)

    plot_all_attack_variants = eval(parameters['general']['plot_all_attack_variants'])
    is_cuda = eval(parameters['general']['is_cuda'])

    MARKERS = ['o', '^', 'x', '*', '+', 'd']
    MARKER_HANDLES = []
    marker_color = 'blue'

    for m in MARKERS:
        MARKER_HANDLES.append(mlines.Line2D([], [], color=marker_color, marker=m, linestyle='None', markersize=10))

    som_pickle_dir = parameters['general']['som_pickle_dir']

    # Single SOM, all evasion methods
    if plot_all_attack_variants:
        print("Plotting all attack variants with a single SOM")

        som_file = parameters['general']['som_pickle_file']

        som_filenames = [som_file]
        positions_to_use = [0]

    # One evasion method per SOM
    else:
        print("Plotting one attack per SOM")

        som_filenames = [
            # TODO - Fill in with 5 SOM's, each trained with one type of adversarial vector
        ]
        positions_to_use = [1, 2, 3, 4, 5]

    base_output_directory = "som_decision_plots"
    if not os.path.exists(base_output_directory):
        os.mkdir(base_output_directory)

    time_string = time.strftime("%m_%d_%Hh_%Mm", time.localtime())
    output_directory = os.path.join(base_output_directory, time_string)
    if not os.path.exists(output_directory):
        os.mkdir(output_directory)

    trained_model_path = parameters['general']['trained_model_path']
    model_weights_base_path = os.path.join(trained_model_path, "[training:{meth}|evasion:{meth}]_{exp_name}-model.pt")
    experiment_name = parameters['general']['experiment_name']

    for som_filename, position in zip(som_filenames, positions_to_use):
        training_methods = ["natural", "dfgsm_k", "rfgsm_k", "bga_k", "bca_k"]

        # 1. LOAD TRAINED SOM MODEL
        start_time = time.time()
        print("Loading SOM")
        som = pickle.load(open(os.path.join(som_pickle_dir, som_filename), "rb"))
        print("Time to load SOM:", round(time.time() - start_time, 2))

        # Get bmus for each neuron
        neuron_high_dim_values = som.codebook
        neuron_high_dim_values = np.reshape(neuron_high_dim_values, (-1, neuron_high_dim_values.shape[-1]))

        neuron_low_dim_mappings = []
        for i in range(som.codebook.shape[0]):
            for j in range(som.codebook.shape[0]):
                # Goes like [0,0], [1,0] ... [9,0], [0,1], [1,1], [2,1] ....
                neuron_low_dim_mappings.append([j, i])

        neuron_low_dim_mappings = np.array(neuron_low_dim_mappings)

        ### 2. COMPUTE BMUS FOR EACH POINT (for new points to be plotted)
        num_points = int(parameters['hyperparam']['num_vectors_each_type'])
        print("Number of points each method:", num_points)
        malicious_vectors, benign_vectors, dfgsm_vectors, rfgsm_vectors, bga_vectors, bca_vectors = load_vectors(num_points, parameters)

        vectors_to_use = [malicious_vectors, benign_vectors, dfgsm_vectors, rfgsm_vectors, bga_vectors, bca_vectors]
        methods_used = ['malicious', 'benign', 'dfgsm', 'rfgsm', 'bga', 'bca']

        if position == 0:
            pass
        elif position == 1:
            vectors_to_use = vectors_to_use[:2]
            methods_used = methods_used[:2]
        else:
            vectors_to_use = list(vectors_to_use[i] for i in [0, 1, position])
            methods_used = list(methods_used[i] for i in [0, 1, position])

        all_vectors = torch.cat(vectors_to_use)
        # 3. GET 2D MAPPINGS (BMU)
        all_vectors_numpy = all_vectors.numpy()

        start_time = time.time()
        print("Computing activation map")
        activation_map = som.get_surface_state(data=all_vectors_numpy)
        print("Finished computing activation map:", time.time() - start_time)

        start_time = time.time()
        print("Computing bmus")
        bmus = som.get_bmus(activation_map)
        print("Finished computing bmus:", time.time() - start_time)

        for training_method in training_methods:
            # Load appropriate pytorch classifier and plot decision heatmap
            model_weights_path = model_weights_base_path.format(meth=training_method, exp_name=experiment_name)
            try:
                model = torch.load(model_weights_path)
                print("Loading Model Weights From: {path}".format(path=model_weights_path))
            except:
                continue

            benign_probabilities = []
            for i in range(len(neuron_high_dim_values)):
                vector = neuron_high_dim_values[i, :]

                if is_cuda:
                    output = model(Variable(torch.FloatTensor(vector).view(1, -1)).cuda())
                else:
                    output = model(Variable(torch.FloatTensor(vector).view(1, -1)))

                benign_prob = torch.exp(output).data[0][0]
                benign_probabilities.append(benign_prob)


            plt.rcParams["font.weight"] = "bold"
            plt.rcParams["axes.labelweight"] = "bold"

            # Plot the model's decision boundary
            plt.scatter(x=neuron_low_dim_mappings[:, 0], y=neuron_low_dim_mappings[:, 1], c=benign_probabilities,
                        cmap='Reds', marker='s')

            plt.colorbar().set_label("Model Benign Probability Belief")
            plt.legend(handles=MARKER_HANDLES[:len(methods_used)], labels=methods_used)

            for i in range(0, len(bmus), num_points):
                points_to_plot = bmus[i:i+num_points]

                index = int(i/num_points)
                method = methods_used[index]

                plt.scatter(points_to_plot[:, 0], points_to_plot[:, 1], marker=MARKERS[index], color=marker_color)

            output_file = "{exp}_plotting_{methods}_som_decision_boundary_{train_method}_model_{size}_by_{size}_{time}.png".format(
                methods="_".join(methods_used), exp=experiment_name, train_method=training_method, time=time.strftime("%m_%d_%Hh_%Mm", time.localtime()), size=som.codebook.shape[0])

            pickle_file = dict()
            pickle_file['points_to_plot'] = points_to_plot
            pickle_file['neuron_low_dim_mappings'] = neuron_low_dim_mappings
            pickle_file['benign_probabilities'] = benign_probabilities

            pickle.dump(pickle_file, open(os.path.join(output_directory, output_file + ".p"), "wb"))

            if matplotlib.get_backend() != 'Agg':
                plt.show()

            plt.savefig(os.path.join(output_directory, output_file))
            plt.clf()
